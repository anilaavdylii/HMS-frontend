{"ast":null,"code":"export { default as mergeWith } from \"lodash.mergewith\";\nexport { default as objectAssign } from \"object-assign\";\nexport function omit(object, keys) {\n  var result = {};\n  Object.keys(object).forEach(key => {\n    if (keys.includes(key)) return;\n    result[key] = object[key];\n  });\n  return result;\n}\nexport function pick(object, keys) {\n  var result = {};\n  keys.forEach(key => {\n    if (key in object) {\n      result[key] = object[key];\n    }\n  });\n  return result;\n}\nexport function split(object, keys) {\n  var picked = {};\n  var omitted = {};\n  Object.keys(object).forEach(key => {\n    if (keys.includes(key)) {\n      picked[key] = object[key];\n    } else {\n      omitted[key] = object[key];\n    }\n  });\n  return [picked, omitted];\n}\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\n\nexport function get(obj, path, fallback, index) {\n  var key = typeof path === \"string\" ? path.split(\".\") : [path];\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) {\n      break;\n    }\n\n    obj = obj[key[index]];\n  }\n\n  return obj === undefined ? fallback : obj;\n}\n\nvar memoize = fn => {\n  var cache = new WeakMap();\n\n  var memoizedFn = (obj, path, fallback, index) => {\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map());\n    }\n\n    var map = cache.get(obj);\n    var key = typeof path === \"string\" ? path.split(\".\") : [path];\n\n    if (map.has(key)) {\n      return map.get(key);\n    }\n\n    var value = fn(obj, path, fallback, index);\n    map.set(key, value);\n    return value;\n  };\n\n  return memoizedFn;\n};\n\nexport var memoizedGet = memoize(get);\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\n\nexport function getWithDefault(path, scale) {\n  return get(scale, path, path);\n}\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\n\nexport function objectFilter(object, fn) {\n  var result = {};\n  Object.keys(object).forEach(key => {\n    var value = object[key];\n    var shouldPass = fn(value, key, object);\n\n    if (shouldPass) {\n      result[key] = value;\n    }\n  });\n  return result;\n}\nexport var filterUndefined = object => objectFilter(object, val => val !== null && val !== undefined);\nexport var objectKeys = obj => Object.keys(obj);\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\n\nexport var fromEntries = entries => entries.reduce((carry, _ref) => {\n  var [key, value] = _ref;\n  carry[key] = value;\n  return carry;\n}, {});","map":{"version":3,"sources":["../../src/object.ts"],"names":["default","result","Object","key","keys","object","picked","omitted","path","index","obj","memoize","fn","cache","memoizedFn","map","value","memoizedGet","get","shouldPass","filterUndefined","objectFilter","val","objectKeys","fromEntries","entries","carry"],"mappings":"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","sourcesContent":["import type { Dict, Omit } from \"./types\"\n\nexport { default as mergeWith } from \"lodash.mergewith\"\nexport { default as objectAssign } from \"object-assign\"\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as K)) return\n    result[key] = object[key]\n  })\n\n  return result as Omit<T, K>\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] }\n\n  keys.forEach((key) => {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  })\n\n  return result\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key]\n    } else {\n      omitted[key] = object[key]\n    }\n  })\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\nexport function get(\n  obj: object,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) {\n  const key = typeof path === \"string\" ? path.split(\".\") : [path]\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) {\n      break\n    }\n\n    obj = obj[key[index]]\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\ntype Handler = (\n  obj: Readonly<object>,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) => any\n\nconst memoize = (fn: Handler) => {\n  const cache = new WeakMap()\n\n  const memoizedFn: Handler = (\n    obj: object,\n    path: string | number,\n    fallback?: any,\n    index?: number,\n  ) => {\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map())\n    }\n\n    const map = cache.get(obj)\n    const key = typeof path === \"string\" ? path.split(\".\") : [path]\n\n    if (map.has(key)) {\n      return map.get(key)\n    }\n\n    const value = fn(obj, path, fallback, index)\n\n    map.set(key, value)\n\n    return value\n  }\n\n  return memoizedFn\n}\n\nexport const memoizedGet = memoize(get)\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return get(scale, path, path)\n}\n\ntype FilterFn<T> = (value: any, key: string, object: T) => boolean\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    const shouldPass = fn(value, key, object)\n    if (shouldPass) {\n      result[key] = value\n    }\n  })\n\n  return result\n}\n\nexport const filterUndefined = (object: Dict) =>\n  objectFilter(object, (val) => val !== null && val !== undefined)\n\nexport const objectKeys = <T extends Dict>(obj: T) =>\n  (Object.keys(obj) as unknown) as (keyof T)[]\n\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\nexport const fromEntries = <T extends unknown>(entries: [string, any][]) =>\n  entries.reduce((carry, [key, value]) => {\n    carry[key] = value\n    return carry\n  }, {}) as T\n"]},"metadata":{},"sourceType":"module"}