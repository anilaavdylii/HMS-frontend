{"ast":null,"code":"import { appendErrors as e } from \"react-hook-form\";\nimport { toNestError as r, validateFieldsNatively as t } from \"@hookform/resolvers\";\n\nvar n = function (n, o, a) {\n  return void 0 === o && (o = {\n    abortEarly: !1\n  }), void 0 === a && (a = {}), function (i, s, u) {\n    try {\n      var c = function () {\n        return l.error ? {\n          values: {},\n          errors: r((n = l.error, o = !u.shouldUseNativeValidation && \"all\" === u.criteriaMode, n.details.length ? n.details.reduce(function (r, t) {\n            var n = t.path.join(\".\");\n\n            if (r[n] || (r[n] = {\n              message: t.message,\n              type: t.type\n            }), o) {\n              var a = r[n].types,\n                  i = a && a[t.type];\n              r[n] = e(n, o, r, t.type, i ? [].concat(i, t.message) : t.message);\n            }\n\n            return r;\n          }, {}) : {}), u)\n        } : (u.shouldUseNativeValidation && t({}, u), {\n          errors: {},\n          values: l.value\n        });\n        var n, o;\n      },\n          v = Object.assign({}, o, {\n        context: s\n      }),\n          l = {},\n          f = function () {\n        if (\"sync\" === a.mode) l = n.validate(i, v);else {\n          var e = function (e, r) {\n            try {\n              var t = e();\n            } catch (e) {\n              return r(e);\n            }\n\n            return t && t.then ? t.then(void 0, r) : t;\n          }(function () {\n            return Promise.resolve(n.validateAsync(i, v)).then(function (e) {\n              l.value = e;\n            });\n          }, function (e) {\n            l.error = e;\n          });\n\n          if (e && e.then) return e.then(function () {});\n        }\n      }();\n\n      return Promise.resolve(f && f.then ? f.then(c) : c());\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n};\n\nexport { n as joiResolver };","map":{"version":3,"sources":["../src/joi.ts"],"names":["error","validateAllFieldCriteria","details","length","reduce","previous","_path","path","join","message","type","types","messages","appendErrors","concat","joiResolver","schema","schemaOptions","abortEarly","resolverOptions","values","context","options","_schemaOptions","Object","assign","result","mode","validate","value","validateAsync","e","errors","toNestError","shouldUseNativeValidation","criteriaMode","validateFieldsNatively"],"mappings":"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","sourcesContent":["import { appendErrors, FieldError } from 'react-hook-form';\nimport { toNestError, validateFieldsNatively } from '@hookform/resolvers';\nimport type { ValidationError } from 'joi';\nimport { Resolver } from './types';\n\nconst parseErrorSchema = (\n  error: ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  error.details.length\n    ? error.details.reduce<Record<string, FieldError>>((previous, error) => {\n        const _path = error.path.join('.');\n\n        if (!previous[_path]) {\n          previous[_path] = { message: error.message, type: error.type };\n        }\n\n        if (validateAllFieldCriteria) {\n          const types = previous[_path].types;\n          const messages = types && types[error.type!];\n\n          previous[_path] = appendErrors(\n            _path,\n            validateAllFieldCriteria,\n            previous,\n            error.type,\n            messages\n              ? ([] as string[]).concat(messages as string[], error.message)\n              : error.message,\n          ) as FieldError;\n        }\n\n        return previous;\n      }, {})\n    : {};\n\nexport const joiResolver: Resolver =\n  (\n    schema,\n    schemaOptions = {\n      abortEarly: false,\n    },\n    resolverOptions = {},\n  ) =>\n  async (values, context, options) => {\n    const _schemaOptions = Object.assign({}, schemaOptions, {\n      context,\n    });\n\n    let result: Record<string, any> = {};\n    if (resolverOptions.mode === 'sync') {\n      result = schema.validate(values, _schemaOptions);\n    } else {\n      try {\n        result.value = await schema.validateAsync(values, _schemaOptions);\n      } catch (e) {\n        result.error = e;\n      }\n    }\n\n    if (result.error) {\n      return {\n        values: {},\n        errors: toNestError(\n          parseErrorSchema(\n            result.error,\n            !options.shouldUseNativeValidation &&\n              options.criteriaMode === 'all',\n          ),\n          options,\n        ),\n      };\n    }\n\n    options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n    return {\n      errors: {},\n      values: result.value,\n    };\n  };\n"]},"metadata":{},"sourceType":"module"}